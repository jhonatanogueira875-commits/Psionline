import React, { useState, useEffect } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from 'firebase/auth';
import { 
    getFirestore, 
    collection, 
    onSnapshot, 
    addDoc, 
    serverTimestamp, 
    query, 
    orderBy,
    doc, 
    updateDoc, 
    deleteDoc 
} from 'firebase/firestore';
import { Calendar, Smile, Frown, Loader, ArrowLeft, Trash2, Edit, X, Check } from 'lucide-react';

// --- CONFIGURAÇÃO FIREBASE E VARIÁVEIS GLOBAIS ---
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Inicializa o Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

// Helper para funções de Áudio (mantidas da versão anterior)
const base64ToArrayBuffer = (base64) => {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
};

const pcmToWav = (pcm16, sampleRate = 16000) => {
    const numChannels = 1;
    const bytesPerSample = 2; 
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;

    const buffer = new ArrayBuffer(44 + pcm16.byteLength);
    const view = new DataView(buffer);
    let offset = 0;

    view.setUint32(offset, 0x52494646, false); offset += 4;
    view.setUint32(offset, 36 + pcm16.byteLength, true); offset += 4;
    view.setUint32(offset, 0x57415645, false); offset += 4;
    view.setUint32(offset, 0x666d7420, false); offset += 4;
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2;
    view.setUint16(offset, numChannels, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, byteRate, true); offset += 4;
    view.setUint16(offset, blockAlign, true); offset += 2;
    view.setUint16(offset, 16, true); offset += 2;
    view.setUint32(offset, 0x64617461, false); offset += 4;
    view.setUint32(offset, pcm16.byteLength, true); offset += 4;

    const pcmData = new Uint8Array(pcm16.buffer);
    for (let i = 0; i < pcm16.byteLength; i++) {
        view.setUint8(offset + i, pcmData[i]);
    }

    return new Blob([buffer], { type: 'audio/wav' });
};

// Mapeamento de humor para voz e estilo de TTS
const voiceMap = {
    'Excelente': { voiceName: 'Puck', style: 'cheerfully' },
    'Bom': { voiceName: 'Kore', style: 'calmly' },
    'Neutro': { voiceName: 'Charon', style: 'in a matter-of-fact tone' },
    'Ruim': { voiceName: 'Fenrir', style: 'in a slightly low tone' },
    'Péssimo': { voiceName: 'Algenib', style: 'in a slow, somber tone' },
};

const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=";
const API_KEY = ""; 

// Componente de Ícone de Humor
const MoodIcon = ({ mood, className = "w-6 h-6" }) => {
    switch (mood) {
        case 'Excelente': return <Smile className={`text-emerald-500 ${className}`} />;
        case 'Bom': return <Smile className={`text-lime-500 ${className}`} />;
        case 'Neutro': return <Smile className={`text-amber-500 ${className}`} />;
        case 'Ruim': return <Frown className={`text-orange-500 ${className}`} />;
        case 'Péssimo': return <Frown className={`text-red-600 ${className}`} />;
        default: return <Smile className={`text-gray-400 ${className}`} />;
    }
};

// Componente de Botão de Fala TTS
const SpeakButton = ({ text, mood }) => {
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const API_KEY = ""; 

    const speak = async () => {
        setIsLoading(true);
        setError(null);
        const { voiceName, style } = voiceMap[mood] || voiceMap['Neutro'];
        const promptText = `Say ${style}: "${text}"`;

        const payload = {
            contents: [{ parts: [{ text: promptText }] }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } }
                }
            },
            model: "gemini-2.5-flash-preview-tts"
        };

        try {
            const response = await fetch(`${API_URL}${API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`TTS API failed: ${errorBody.error?.message || response.statusText}`);
            }

            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 16000;
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                const audioUrl = URL.createObjectURL(wavBlob);
                
                const audio = new Audio(audioUrl);
                audio.play();

                audio.onended = () => { URL.revokeObjectURL(audioUrl); };
            } else {
                throw new Error("Resposta de áudio inválida ou incompleta.");
            }

        } catch (err) {
            console.error("Erro ao gerar ou reproduzir áudio:", err);
            setError("Falha ao gerar áudio.");
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="flex flex-col items-center">
            {error && <span className="text-red-500 text-xs mt-1">{error}</span>}
            <button
                onClick={speak}
                disabled={isLoading}
                className={`mt-1 px-3 py-1 text-xs font-medium rounded-full transition duration-150 ${
                    isLoading 
                    ? 'bg-blue-300 text-white cursor-not-allowed' 
                    : 'bg-blue-500 hover:bg-blue-600 text-white shadow-md'
                }`}
            >
                {isLoading ? <Loader className="w-4 h-4 animate-spin inline-block" /> : 'Ouvir Nota'}
            </button>
        </div>
    );
};

// Componente Modal de Edição (Mantido)
const EditModal = ({ record, userId, appId, onSave, onClose, db, moods, MoodIcon }) => {
    const [editingMood, setEditingMood] = useState(record.mood);
    const [editingNote, setEditingNote] = useState(record.note);
    const [isSaving, setIsSaving] = useState(false);
    const [error, setError] = useState(null);

    const handleSave = async (e) => {
        e.preventDefault();
        if (editingNote.trim() === '') {
            setError("A nota não pode estar vazia.");
            return;
        }

        setIsSaving(true);
        setError(null);

        try {
            const recordRef = doc(db, 'artifacts', appId, 'users', userId, 'mood_records', record.id);
            await updateDoc(recordRef, {
                mood: editingMood,
                note: editingNote.trim(),
            });
            onSave(); 
        } catch (err) {
            console.error("Erro ao salvar edição:", err);
            setError(`Falha ao salvar. ${err.message}`);
        } finally {
            setIsSaving(false);
        }
    };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 transition-opacity duration-300">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 relative">
                <button 
                    onClick={onClose} 
                    className="absolute top-3 right-3 text-gray-400 hover:text-gray-600 transition"
                    title="Fechar Edição"
                >
                    <X className="w-6 h-6" />
                </button>

                <h2 className="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Editar Registro</h2>
                
                {error && (
                    <div className="bg-red-100 text-red-700 p-2 rounded-lg mb-4 text-sm">{error}</div>
                )}

                <form onSubmit={handleSave}>
                    {/* Seleção de Humor para Edição */}
                    <label className="block text-gray-700 font-medium mb-2">Selecione o Humor:</label>
                    <div className="flex flex-wrap gap-2 mb-4 justify-start">
                        {moods.map((mood) => (
                            <button
                                key={mood}
                                type="button"
                                onClick={() => setEditingMood(mood)}
                                className={`flex items-center px-4 py-2 rounded-full text-sm font-medium transition duration-200 shadow-sm ${
                                    editingMood === mood 
                                    ? 'bg-blue-600 text-white ring-2 ring-blue-300'
                                    : 'bg-gray-200 text-gray-700 hover:bg-blue-100'
                                }`}
                            >
                                <MoodIcon mood={mood} className="w-5 h-5" />
                                <span className="ml-2">{mood}</span>
                            </button>
                        ))}
                    </div>

                    {/* Nota para Edição */}
                    <label className="block text-gray-700 font-medium mb-2 mt-4">Nota:</label>
                    <textarea
                        value={editingNote}
                        onChange={(e) => setEditingNote(e.target.value)}
                        placeholder="Edite a sua nota..."
                        rows="4"
                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150 resize-none"
                        required
                    />

                    <div className="flex justify-end mt-6 space-x-3">
                        <button
                            type="button"
                            onClick={onClose}
                            className="bg-gray-300 text-gray-800 font-medium py-2 px-6 rounded-xl hover:bg-gray-400 transition shadow-md"
                            disabled={isSaving}
                        >
                            Cancelar
                        </button>
                        <button
                            type="submit"
                            className="bg-green-500 text-white font-bold py-2 px-6 rounded-xl hover:bg-green-600 transition shadow-lg disabled:opacity-50 flex items-center justify-center"
                            disabled={isSaving}
                        >
                            {isSaving ? (
                                <><Loader className="w-5 h-5 mr-2 animate-spin" /> Salvando...</>
                            ) : 'Salvar Edição'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};


// Componente principal
const App = () => {
    const [userId, setUserId] = useState(null);
    const [moodRecords, setMoodRecords] = useState([]);
    const [newMood, setNewMood] = useState('Bom');
    const [newNote, setNewNote] = useState('');
    const [isLoading, setIsLoading] = useState(true);
    const [errorMessage, setErrorMessage] = useState('');
    
    // Estados para edição e exclusão
    const [editingRecord, setEditingRecord] = useState(null); 
    const [deletingRecordId, setDeletingRecordId] = useState(null); // ID do registro pendente de exclusão

    const moods = ['Excelente', 'Bom', 'Neutro', 'Ruim', 'Péssimo'];

    const handleSignOut = async () => {
        try {
            setIsLoading(true); 
            setUserId(null); 
            setMoodRecords([]);
            await signOut(auth);
        } catch (error) {
            console.error("Erro ao sair:", error);
            setErrorMessage(`Erro ao sair: ${error.message}`);
            setIsLoading(false); 
        }
    };

    // --- FUNÇÕES DE EXCLUSÃO (NOVO FLUXO) ---

    // 1. Inicia o processo de exclusão, configurando o ID do registro a ser excluído
    const handleDeleteClick = (recordId) => {
        setDeletingRecordId(recordId);
    };

    // 2. Cancela o processo de exclusão
    const handleCancelDelete = () => {
        setDeletingRecordId(null);
    };

    // 3. Executa a exclusão no Firebase
    const handleConfirmDelete = async (recordId) => {
        if (!userId) {
            setErrorMessage("Erro: Usuário não autenticado para exclusão.");
            return;
        }

        try {
            const recordRef = doc(db, 'artifacts', appId, 'users', userId, 'mood_records', recordId);
            await deleteDoc(recordRef);
            setErrorMessage('');
            setDeletingRecordId(null); // Limpa o estado após sucesso
        } catch (error) {
            console.error("Erro ao deletar registro:", error);
            // Mensagem de erro aprimorada para ajudar a diagnosticar regras de segurança
            setErrorMessage(`Falha ao deletar: ${error.message}. Isso pode ser um problema de permissão (Regras do Firestore).`);
            setDeletingRecordId(null); 
        }
    };

    // --- FUNÇÕES DE EDIÇÃO (MANTIDAS) ---

    const handleStartEdit = (record) => {
        setEditingRecord(record);
    };

    const handleCloseEdit = () => {
        setEditingRecord(null);
    };


    // 1. Efeito para Autenticação e Configuração Inicial
    useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            if (user) {
                setUserId(user.uid);
            } else {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Erro na autenticação:", error);
                    setErrorMessage(`Falha na autenticação: ${error.message}`);
                    setUserId(crypto.randomUUID()); 
                }
            }
            setIsLoading(false);
        });

        return () => unsubscribe();
    }, []);

    // 2. Efeito para OUVINTE DO FIRESTORE 
    useEffect(() => {
        if (!userId || isLoading) return;

        const userMoodsRef = collection(db, 'artifacts', appId, 'users', userId, 'mood_records');
        const q = query(userMoodsRef, orderBy('createdAt', 'desc'));

        console.log(`Escutando dados em: /artifacts/${appId}/users/${userId}/mood_records`);
        
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const records = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data(),
                date: doc.data().createdAt ? doc.data().createdAt.toDate() : new Date(),
            }));
            setMoodRecords(records);
            setErrorMessage('');
        }, (error) => {
            console.error("Erro ao escutar registros de humor:", error);
            setErrorMessage(`Erro de Permissão: ${error.message}. Verifique as regras de segurança do Firestore ou a autenticação.`);
        });

        return () => unsubscribe();
    }, [userId, isLoading]); 

    // Função para adicionar um novo registro
    const addMoodRecord = async (e) => {
        e.preventDefault();
        if (!userId || newNote.trim() === '') {
            setErrorMessage("Por favor, selecione um humor e adicione uma nota.");
            return;
        }
        
        const userMoodsRef = collection(db, 'artifacts', appId, 'users', userId, 'mood_records');

        try {
            await addDoc(userMoodsRef, {
                mood: newMood,
                note: newNote.trim(),
                createdAt: serverTimestamp(),
            });
            setNewNote('');
            setErrorMessage('');
        } catch (error) {
            console.error("Erro ao adicionar registro:", error);
            setErrorMessage(`Erro ao salvar: ${error.message}`);
        }
    };

    const formatDate = (date) => {
        return date.toLocaleDateString('pt-BR', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    };

    if (isLoading) {
        return (
            <div className="flex justify-center items-center h-screen bg-gray-50">
                <Loader className="w-8 h-8 animate-spin text-blue-500" />
                <span className="ml-2 text-gray-700">Carregando autenticação...</span>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gray-100 p-4 sm:p-8 font-sans">
            <header className="mb-8 text-center relative">
                <h1 className="text-3xl font-bold text-gray-800 flex items-center justify-center">
                    <Calendar className="w-7 h-7 mr-3 text-blue-500" />
                    Rastreador de Humor
                </h1>
                <p className="text-sm text-gray-600 mt-2">
                    Seu ID de Usuário: <code className="bg-white p-1 rounded font-mono text-xs">{userId || 'Não Autenticado'}</code>
                </p>
                {/* Botão de Sair */}
                {userId && (
                    <button
                        onClick={handleSignOut}
                        className="absolute top-0 right-0 bg-red-500 text-white font-medium py-1 px-3 rounded-lg hover:bg-red-600 transition duration-150 text-sm flex items-center shadow-md"
                        title="Sair da Sessão"
                    >
                        <ArrowLeft className="w-4 h-4 mr-1" /> Sair
                    </button>
                )}
            </header>

            {errorMessage && (
                <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg mb-6 shadow-md" role="alert">
                    <p className="font-bold">Erro de Aplicação</p>
                    <p className="text-sm">{errorMessage}</p>
                    {errorMessage.includes("Regras do Firestore") && (
                        <p className="text-xs mt-1">Se o problema persistir, verifique se a regra `allow delete` está configurada para o seu usuário.</p>
                    )}
                </div>
            )}

            {/* Formulário de Novo Registro (Mantido) */}
            <div className="bg-white p-6 rounded-xl shadow-2xl mb-8 border-t-4 border-blue-500">
                <h2 className="text-xl font-semibold text-gray-700 mb-4">Como você está se sentindo?</h2>
                <form onSubmit={addMoodRecord}>
                    {/* Seleção de Humor */}
                    <div className="flex flex-wrap gap-2 mb-4 justify-center sm:justify-start">
                        {moods.map((mood) => (
                            <button
                                key={mood}
                                type="button"
                                onClick={() => setNewMood(mood)}
                                className={`flex items-center px-4 py-2 rounded-full text-sm font-medium transition duration-200 shadow-md ${
                                    newMood === mood 
                                    ? 'bg-blue-600 text-white ring-2 ring-blue-300 transform scale-105'
                                    : 'bg-gray-200 text-gray-700 hover:bg-blue-100'
                                }`}
                                disabled={!userId}
                            >
                                <MoodIcon mood={mood} />
                                <span className="ml-2">{mood}</span>
                            </button>
                        ))}
                    </div>

                    {/* Nota/Detalhe */}
                    <textarea
                        value={newNote}
                        onChange={(e) => setNewNote(e.target.value)}
                        placeholder={`Escreva uma nota sobre o seu humor (${newMood.toLowerCase()})...`}
                        rows="3"
                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150 resize-none"
                        required
                        disabled={!userId}
                    />

                    <div className="flex justify-end mt-4">
                        <button
                            type="submit"
                            className="bg-blue-500 text-white font-bold py-2 px-6 rounded-xl hover:bg-blue-600 transition duration-150 shadow-lg disabled:opacity-50"
                            disabled={!userId || newNote.trim() === ''}
                        >
                            Salvar Registro
                        </button>
                    </div>
                </form>
            </div>

            {/* Lista de Registros */}
            <h2 className="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Seus Registros Anteriores ({moodRecords.length})</h2>
            <div className="space-y-4">
                {moodRecords.length === 0 ? (
                    <p className="text-gray-500 italic p-4 bg-white rounded-xl shadow-md">
                        Nenhum registro de humor encontrado. Adicione o primeiro!
                    </p>
                ) : (
                    moodRecords.map((record) => (
                        <div 
                            key={record.id} 
                            className="flex flex-col sm:flex-row justify-between items-start sm:items-center bg-white p-4 rounded-xl shadow-md hover:shadow-lg transition duration-200 border-l-4 border-blue-400 relative"
                        >
                            <div className="flex items-center mb-2 sm:mb-0 w-full sm:w-auto">
                                <MoodIcon mood={record.mood} className="w-7 h-7" />
                                <div className="ml-4 flex-1 min-w-0">
                                    <p className="text-lg font-semibold text-gray-800">{record.mood}</p>
                                    <p className="text-xs text-gray-500 italic">{formatDate(record.date)}</p>
                                </div>
                            </div>
                            <div className="flex-1 min-w-0 sm:mx-6 my-2 sm:my-0">
                                <p className="text-gray-700 break-words">{record.note}</p>
                            </div>
                            
                            <div className="flex space-x-2 items-center justify-end w-full sm:w-auto mt-2 sm:mt-0">
                                {/* Lógica de Confirmação de Exclusão */}
                                {deletingRecordId === record.id ? (
                                    <div className="flex items-center space-x-2 p-2 bg-red-100 rounded-lg border border-red-300 transition duration-300">
                                        <span className="text-red-700 text-sm font-medium">Confirma?</span>
                                        <button
                                            onClick={() => handleConfirmDelete(record.id)}
                                            className="p-1 text-white bg-red-600 rounded-full hover:bg-red-700 transition"
                                            title="Confirmar Exclusão"
                                        >
                                            <Check className="w-5 h-5" />
                                        </button>
                                        <button
                                            onClick={handleCancelDelete}
                                            className="p-1 text-red-600 bg-white border border-red-300 rounded-full hover:bg-gray-50 transition"
                                            title="Cancelar"
                                        >
                                            <X className="w-5 h-5" />
                                        </button>
                                    </div>
                                ) : (
                                    <>
                                        <SpeakButton text={record.note} mood={record.mood} />
                                        <button
                                            onClick={() => handleStartEdit(record)}
                                            className="p-2 text-blue-600 rounded-full hover:bg-blue-100 transition shadow-sm"
                                            title="Editar Registro"
                                        >
                                            <Edit className="w-5 h-5" />
                                        </button>
                                        <button
                                            onClick={() => handleDeleteClick(record.id)}
                                            className="p-2 text-red-600 rounded-full hover:bg-red-100 transition shadow-sm"
                                            title="Excluir Registro"
                                        >
                                            <Trash2 className="w-5 h-5" />
                                        </button>
                                    </>
                                )}
                            </div>
                        </div>
                    ))
                )}
            </div>
            
            {/* Renderiza o Modal de Edição se um registro estiver selecionado */}
            {editingRecord && (
                <EditModal 
                    record={editingRecord}
                    userId={userId}
                    appId={appId}
                    onSave={handleCloseEdit}
                    onClose={handleCloseEdit}
                    db={db}
                    moods={moods}
                    MoodIcon={MoodIcon}
                />
            )}
        </div>
    );
};

export default App;
